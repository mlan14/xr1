{
  "id": 4209,
  "name": "Fork of New Composed Shader",
  "fragment": "#extension GL_OES_standard_derivatives : enable\n\nprecision highp float;\nprecision highp int;\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\nvarying vec2 vUv;\nconst float sections = 4.;\nfloat ttime = 0.;\nfloat cid = 0., lid = 0.;\nmat3 m1;\nmat3 m2;\nmat3 getRotXMat(float a) \n                                                        {\n                                                            return mat3(1., 0., 0., 0., cos(a), -sin(a), 0., sin(a), cos(a));\n                                                        }\nmat3 getRotYMat(float a) \n                                                        {\n                                                            return mat3(cos(a), 0., sin(a), 0., 1., 0., -sin(a), 0., cos(a));\n                                                        }\nmat3 getRotZMat(float a) \n                                                        {\n                                                            return mat3(cos(a), -sin(a), 0., sin(a), cos(a), 0., 0., 0., 1.);\n                                                        }\nvec2 path(float t) \n                                                        {\n                                                            return vec2(cos(t * 0.08), sin(t * 0.08)) * 4.;\n                                                        }\nfloat cAtan(vec2 uv) \n                                                        {\n                                                            float a = 0.;\n                                                            if (uv.x >= 0.) a = atan(uv.x, uv.y);\n                                                             if (uv.x < 0.) a = 3.14159 - atan(uv.x, -uv.y);\n                                                             return a;\n                                                        }\nfloat GetID(vec2 uv) \n                                                        {\n                                                            return cAtan(uv) * floor(sections) * .5 / 3.14159;\n                                                        }\nfloat pattern(vec3 p, mat3 m, float s, float id) \n                                                        {\n                                                            float r = 0.;\n                                                            p = abs(fract(p * m * s) - 0.5);\n                                                            if (id > 3.) r = max(min(abs(p.x), abs(p.z)), abs(p.y));\n else if (id > 2.) r = max(p.x, abs(p.y) + p.z);\n else if (id > 1.) r = length(p);\n else if (id > 0.) r = max(p.x, -p.y);\n                                                             return r;\n                                                        }\nfloat displace(vec3 p, float id) \n                                                        {\n                                                            vec3 a = vec3(0), b = a;\n                                                            if (id > 3.) a = vec3(-0.32, 0.5, .5), b = vec3(0);\n else if (id > 2.) a = vec3(0.46, 0.42, -1.5), b = vec3(0);\n else if (id > 1.) a = vec3(0.36, 0.2, -2.28), b = vec3(0.36, 0.24, 1.62);\n else if (id > 0.) a = vec3(0.62, 0.62, -1.02), b = vec3(0);\n                                                             return (1. - min(pattern(p, m1, a.x, id), pattern(p, m2, a.y, id))) * a.z + (1. - min(pattern(p, m1, b.x, id), pattern(p, m2, b.y, id))) * b.z;\n                                                        }\nfloat smin(float a, float b) \n                                                        {\n                                                            float k = 1.;\n                                                            float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n                                                            return mix(b, a, h) - k * h * (1.0 - h);\n                                                        }\nvec4 map(vec3 p) \n                                                        {\n                                                            p.xy -= path(p.z);\n                                                            float r = mix(displace(p, lid), displace(p, cid), fract(cid));\n                                                            p *= getRotZMat(p.z * 0.05);\n                                                            p = mod(p, 10.) - 5.;\n                                                            return vec4(smin(length(p.xz), abs(p.y)) - 1. + r, p);\n                                                        }\nvec3 nor(vec3 pos, float k) \n                                                        {\n                                                            vec3 eps = vec3(k, 0., 0.);\n                                                            vec3 nor = vec3(map(pos + eps.xyy).x - map(pos - eps.xyy).x, map(pos + eps.yxy).x - map(pos - eps.yxy).x, map(pos + eps.yyx).x - map(pos - eps.yyx).x);\n                                                            return normalize(nor);\n                                                        }\nvec3 blackbody(float Temp) \n                                                        {\n                                                            vec3 col = vec3(255.);\n                                                            col.x = 56100000. * pow(Temp, (-3. / 2.)) + 148.;\n                                                            col.y = 100.04 * log(Temp) - 623.6;\n                                                            if (Temp > 6500.) col.y = 35200000. * pow(Temp, (-3. / 2.)) + 184.;\n                                                             col.z = 194.18 * log(Temp) - 1448.6;\n                                                            col = clamp(col, 0., 255.) / 255.;\n                                                            if (Temp < 1000.) col *= Temp / 1000.;\n                                                             return col;\n                                                        }\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n                                                        {\n                                                            vec3 n;\n                                                            float s = 0.;\n                                                            const int iter = 8;\n                                                            for (int i = 0;\n i < iter; i++) \n                                                            {\n                                                                n = nor(surfPoint, prec);\n                                                                surfPoint = surfPoint - n * ms;\n                                                                s += map(surfPoint).x;\n                                                            }\n                                                            return 1. - s / (ms * float(iter));\n                                                        }\nfloat SubDensity(vec3 p, float s) \n                                                        {\n                                                            vec3 n = nor(p, s);\n                                                            return map(p - n * s).x;\n                                                        }\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n) \n                                                        {\n                                                            n = max((abs(n) - .2) * 7., .001);\n                                                            n /= (n.x + n.y + n.z);\n                                                            p = (texture2D(tex, p.yz) * n.x + texture2D(tex, p.zx) * n.y + texture2D(tex, p.xy) * n.z).xyz;\n                                                            return p * p;\n                                                        }\nvec3 doBumpMap(sampler2D tx, in vec3 p, in vec3 n, float bf) \n                                                        {\n                                                            const vec2 e = vec2(0.001, 0);\n                                                            mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n                                                            vec3 g = vec3(0.299, 0.587, 0.114) * m;\n                                                            g = (g - dot(tex3D(tx, p, n), vec3(0.299, 0.587, 0.114))) / e.x;\n                                                            g -= n * dot(n, g);\n                                                            return normalize(n + g * bf);\n                                                        }\nvec4 params(vec4 f, float id) \n                                                        {\n                                                            vec4 c = f;\n                                                            if (id > 3.) c = f.zwyw;\n else if (id > 2.) c = f.zyzw;\n else if (id > 1.) c = f.yzyx;\n else if (id > 0.) c = f.xyzw;\n                                                             return c;\n                                                        }\nvec4 shade(vec3 ro, vec3 rd, float d, vec3 lp) \n                                                        {\n                                                            vec3 p = ro + rd * d;\n                                                            float sb = SubDensity(p, 0.001, 0.1);\n                                                            vec3 bb = blackbody(100. * sb + 100.);\n                                                            vec3 ld = normalize(lp - p);\n                                                            vec3 n = nor(p, .01);\n                                                            vec3 refl = reflect(rd, n);\n                                                            float amb = 0.08;\n                                                            float diff = clamp(dot(n, ld), 0.0, 1.0);\n                                                            float fre = pow(clamp(1. + dot(n, rd), 0.0, 1.0), 16.);\n                                                            float spe = pow(clamp(dot(refl, ld), 0.0, 1.0), 25.);\n                                                            float sss = 1. - SubDensity(p * 0.1, 5.) * 0.5;\n                                                            return vec4((diff + fre + bb.x * sss) * amb + diff * 0.5, (diff + fre + bb * sb + sss * 0.3) * amb + spe * 0.6 - diff * sss * 0.05);\n                                                        }\nvec3 cam(vec2 g, vec2 si, vec3 ro, vec3 cv) \n                                                        {\n                                                            vec2 uv = (g + g - si) / si.y;\n                                                            vec3 cu = normalize(vec3(0, 1, 0));\n                                                            vec3 z = normalize(cv - ro);\n                                                            vec3 x = normalize(cross(cu, z));\n                                                            vec3 y = cross(z, x);\n                                                            return normalize(z + uv.x * x + uv.y * y);\n                                                        }\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n                                                        {\n                                                            vec4 f = vec4(0);\n                                                            vec2 g = fragCoord.xy;\n                                                            vec2 si = resolution.xy;\n                                                            mat3 mx = getRotXMat(-7.);\n                                                            mat3 my = getRotYMat(-5.);\n                                                            mat3 mz = getRotZMat(-3.);\n                                                            m1 = mx * my * mz;\n                                                            m2 = m1 * m1;\n                                                            ttime = time * 8.;\n                                                            vec3 cu = vec3(0, 1, 0);\n                                                            vec3 cv = vec3(path(ttime + .1), ttime + .1);\n                                                            vec3 ro = vec3(path(ttime), ttime);\n                                                            vec3 lp = vec3(path(ro.z + 7.), ro.z + 7.);\n                                                            vec3 cp = vec3(path(ro.z + 25.2), ro.z + 25.2);\n                                                            vec3 rd = cam(g, si, ro, cv);\n                                                            vec2 rdID = rd.xy - normalize(cp - ro).xy;\n                                                            rdID = cam(si * 0.5, si, ro, cv).xy - normalize(cp - ro).xy;\n                                                            float id = GetID(rdID);\n                                                            cid = id;\n                                                            lid = cid - 1.;\n                                                            if (lid < 0.) lid = id + sections - 1.;\n                                                             vec2 q = vUv.xy / resolution;\n                                                            float yy = radians(180. * (q.y - .5));\n                                                            float xz = radians(360. * (q.x - .25)) + time / 60.;\n                                                            rd = vec3(sin(xz) * cos(yy), sin(yy), cos(xz) * cos(yy));\n                                                            float s = 1.;\n                                                            float d = 0.;\n                                                            for (int i = 0;\n i < 60; i++) \n                                                            {\n                                                                if (log(d * d / s / 1e5) > 0.) break;\n                                                                 d += s = map(ro + rd * d).x * .6;\n                                                            }\n                                                            f = shade(ro, rd, d, lp);\n                                                            f = mix(params(f, lid), params(f, cid), fract(cid));\n                                                            f = f + f.x * 0.3;\n                                                            f = mix(f, vec4(0.8), 1.0 - exp(-0.001 * d * d));\n                                                            fragColor = sqrt(f * f * f * 2.);\n                                                        }\nvec4 Fractal_Cavern_Sphere_Projection1582054477170_463_main() \n                                                        {\n                                                            vec4 Fractal_Cavern_Sphere_Projection1582054477170_463_gl_FragColor = vec4(0.0);\n                                                            mainImage(Fractal_Cavern_Sphere_Projection1582054477170_463_gl_FragColor, vUv.xy);\n                                                            Fractal_Cavern_Sphere_Projection1582054477170_463_gl_FragColor.a = 1.;\n                                                            return Fractal_Cavern_Sphere_Projection1582054477170_463_gl_FragColor *= 1.0;\n                                                        }\nvoid main() \n                                                        {\n                                                            gl_FragColor = Fractal_Cavern_Sphere_Projection1582054477170_463_main();                                                        }\n",
  "vertex": "precision highp float;\nprecision highp int;\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform float time;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec2 vUv2;\nvec4 Fractal_Cavern_Sphere_Projection1582054477170_463_main() \n                                                        {\n                                                            vec4 Fractal_Cavern_Sphere_Projection1582054477170_463_gl_Position = vec4(0.0);\n                                                            vNormal = normal;\n                                                            vUv = uv;\n                                                            vUv2 = uv2;\n                                                            vPosition = position;\n                                                            Fractal_Cavern_Sphere_Projection1582054477170_463_gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                                                            return Fractal_Cavern_Sphere_Projection1582054477170_463_gl_Position *= 1.0;\n                                                        }\nvoid main() \n                                                        {\n                                                            gl_Position = Fractal_Cavern_Sphere_Projection1582054477170_463_main();                                                        }\n",
  "uniforms": {
    "cameraPosition": {
      "type": "v3",
      "glslType": "vec3"
    },
    "time": {
      "type": "f",
      "glslType": "float"
    },
    "mouse": {
      "value": {
        "x": 0,
        "y": 0
      },
      "type": "v2",
      "glslType": "vec2"
    },
    "resolution": {
      "value": {
        "x": "1",
        "y": "1"
      },
      "type": "v2",
      "glslType": "vec2"
    }
  },
  "url": "http://shaderfrog.com/app/view/4209",
  "user": {
    "username": "mhellar",
    "url": "http://shaderfrog.com/app/profile/andrewray"
  }
}